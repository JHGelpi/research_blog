# 30/60/90 day plan
## First 30 days: Diagnose, earn trust, stop the bleeding

### Outcomes by Day 30

- You have a clear map of the current state (people, platforms, workflows, costs, pain).
- You’ve delivered 1–2 visible early wins that reduce real friction.
- You’ve established non-negotiable operating guardrails: reliability, ownership, and decision rights.

#### What you do
1) Run a structured “listening + forensics” tour
	- Meet each manager 1:1, then key ICs, then top consumers (DS/DA/DE) and infra/SRE partners.
	- Collect: top incidents, top toil, top UX complaints, top “we can’t change because…” constraints.
2) Inventory the orchestration landscape (brutally)
	- Catalog every scheduler/orchestrator in play: UI, APIs, runtime targets, dependency model, auth, tenancy, alerting, SLAs, lineage, backfill behavior.
	- Create a workflow taxonomy: batch ETL, ML training, streaming triggers, long-running services, ad-hoc jobs.
3) Establish baseline metrics (you can’t unify what you can’t measure)
	- Job success rate, retry rate, mean time to recovery, median time-to-debug, queue times, compute cost per run, “time-to-first-pipeline”, and user satisfaction.
	- Define service reliability targets using SLO/error-budget thinking (forces tradeoffs into daylight).
4) Pick early wins that buy credibility
	- Examples:
		- Standardize alerting + runbook template across current schedulers.
		- One “unified run view” dashboard pulling status from multiple systems.
		- Fix the most hated UX step (credentials, reruns, parameter input, log retrieval). Early wins matter because they build momentum and permission to make harder calls.

#### Deliverables
- “Current State Orchestration Map” (systems + owners + risk + cost).
- Baseline metrics dashboard.
- Early-win release #1.
- A clear “why we’re changing” narrative (urgency + vision + what stays stable).

## Days 31–60: Define the target product, target architecture, and migration rules

### Outcomes by Day 60

- You have a decision-ready target: unified UX + execution strategy.
- You have a migration game plan that doesn’t require heroics.
- You’ve built the guiding coalition (the people who will carry this change into teams).

### What you do

1) Define the “North Star” UX (and the mental model)
	- Decide what your users “see”: assets? DAGs? jobs? runs? a catalog?
	- Codify the top user journeys:
		- create pipeline, schedule, manual run, rerun/backfill, debug, notify, audit/lineage.
	- Hard rule: every workflow must be discoverable + diagnosable in < 2 minutes.
2) Define the target architecture as two planes
	- Control plane (UX/API, governance, lineage/metadata, permissions)
	- Execution plane (K8s jobs, queues/admission, placement constraints, scaling)
		This separation is what lets you unify UX while evolving runtime. (It also prevents Conway’s Law from hardening your legacy silos into the new design.)
3) Adopt platform-as-a-product discipline
	- Treat orchestration as a platform team offering paved roads, not bespoke favors.
	- Stand up a lightweight product cadence: roadmap, intake triage, SLAs, release notes.
4) Lock in standards that enable unification
	- Lineage/event standard: emit OpenLineage (or equivalent) as a first-class requirement.
	- Reliability & change policy: SLOs + error budget policy.
	- K8s execution governance: decide your stance on queueing/admission (Kueue/Volcano) and placement controls (taints/tolerations, topology spread, priorities).
5) Write the migration rules (this is where leaders earn their paycheck)
	- “No new net-new workflows on legacy systems after date X.”
	- “All pipelines must register in the catalog and emit lineage after date Y.”
	- “We will migrate by value stream; the first wave is chosen by impact + risk.”

### Deliverables
- Target UX + top workflows (wireframes or clickable prototype is ideal).
- Target architecture (control plane vs execution plane) with key decisions.
- Standards doc: lineage, alerting, auth/RBAC, environment promotion, retry/backfill semantics.
- Migration policy + cutover criteria.

## Days 61–90: Prove it with a pilot, operationalize, and scale the change

### Outcomes by Day 90
- A pilot cohort is live on the unified experience.
- You’ve created the migration factory (repeatable onboarding + conversion path).
- You have a credible 12-month roadmap and governance model.

### What you do
1) Launch a real pilot (not a demo)
	- Pick 1–2 value streams that include DS/DA/DE use cases and at least one “hairy” dependency case.
	- Require: catalog registration, lineage, alerting, on-call routing, and a backfill/rerun story.
2) Stand up the “migration factory”
	- Templates, connectors, conversion guides, office hours, and a small strike team that removes friction.
	- Make success measurable: time-to-migrate, incidents, cost deltas, user satisfaction.
3) Operationalize governance
	- Decision rights: what the platform mandates vs what teams can choose.
	- Intake: feature requests vs break-fix vs migrations.
	- Metrics reviewed weekly; publish progress (momentum is the oxygen of change).
4) Scale the change with ADKAR thinking
	- Awareness/Desire: clear “why” and what pain goes away.
	- Knowledge/Ability: training + docs + paved paths.
	- Reinforcement: deprecations, incentives, and executive air cover.

### Deliverables
- Pilot GA + postmortem + iteration plan.
- Migration playbook + tooling.
- 12-month roadmap with milestones and deprecation timeline.
- Operating model: SLOs/error budgets, incident response, release cadence.

## The hard stances to take on Day 1
- You are not “standardizing tools.” You’re standardizing a user experience and contract. Tools can vary underneath if the contract is consistent.
- No platform without observability + lineage + rerun/backfill ergonomics. These are table stakes for trust.
- Treat orchestration as a product. If you don’t, you’ll drown in special cases.

---


# 1) Exec-ready one-page 30/60/90 plan — Director of Orchestration

## Mission (what we’re changing)
Unify job scheduling/orchestration across legacy systems into one consistent user experience and contract (discover → run → debug → audit), while modernizing execution toward Kubernetes-native, policy-driven workload placement.

## North Star outcomes (12 months)
- Single “orchestration console” (UI + API) for all workflows (even before everything migrates).
- Standard contract: lineage/metadata, auth/RBAC, retries/backfills, alerts, SLOs.
- Execution plane that supports queueing/admission + placement policies (fairness + cost).
Treat orchestration like a product (internal platform) with paved-road adoption.

## 0–30 days: Diagnose + trust + stop the bleeding
### By Day 30, you ship 1–2 wins and have hard data.
- People + operating model
	- 1:1s with every manager + key ICs; set “how we work” norms.
	- Establish decision rights: what’s centralized vs team-owned.
- Orchestration inventory
	- Every scheduler/orchestrator, critical flows, SLAs, costs, incident history, ownership.
	- Create a “workflow taxonomy” (ETL batch, ML training, ad-hoc, streaming triggers, long-running).
- Reliability baseline
	- Define initial SLOs/SLIs for orchestration service and top critical pipelines.
	- Draft an error budget policy so reliability vs feature tradeoffs aren’t political.
- Early wins (non-negotiable)
	- A unified “run view” (even if it aggregates multiple systems).
	- Standard alerting + runbook template + on-call routing.
	- Fix the #1 friction point (auth/secrets, logs, rerun/backfill UX).

## 31–60 days: Decide target UX + architecture + migration rules

### By Day 60, you’re decision-ready and aligned.
- Target UX (“one mental model”)
	- Define canonical user journeys: create, schedule, parameterize, rerun/backfill, debug, notify, audit/lineage.
	- Establish a single vocabulary (job/run/asset/flow) and stick to it.
- Target architecture (two planes)
	- Control plane: UX + APIs + metadata/lineage + RBAC + policy.
	- Execution plane: K8s jobs, admission/queueing, placement constraints, autoscaling.
- Change coalition + momentum
	- Create a cross-org “guiding coalition” and publish the vision + near-term wins.
- Rules of the road
	- “No net-new on legacy after Date X.”
	- “All workflows must register + emit lineage after Date Y.”
	- “Migration happens in waves with entry/exit criteria.”
## 61–90 days: Pilot + migration factory + deprecation timeline

### By Day 90, you have a real pilot in prod and a repeatable conversion path.
- Pilot cohort (real production value stream)
	- Includes DS/DA/DE use cases + at least one “hairy” dependency chain.
	- Requires: lineage, alerting, backfill/rerun, SLO reporting.
- Migration factory
	- Templates, connectors, conversion guide, office hours, dedicated strike team.
	- Metrics: time-to-migrate, incident delta, cost delta, user satisfaction.
- Reinforcement plan
	- Training + self-service docs + incentives + hard deprecation dates (ADKAR).

## What you measure weekly (no vanity metrics)
- Adoption: % workflows visible in console, % emitting lineage, % under SLOs.
- Reliability: success rate, MTTR, mean debug time, incident count/severity.
- Efficiency: queue time, runtime variance, cost/run, utilization.
- DX/UX: time-to-first-pipeline, NPS-like pulse per persona.

## Why this works: It bakes in momentum (short-term wins), coalition building, and barrier removal—Kotter’s recipe for change at scale.

# 2) Orchestration unification scorecard (tool + architecture evaluation rubric)
_Score each candidate 1–5. Weighting differs by persona; you’ll unify by optimizing the weighted total, not by picking the “most popular tool.”_

## Categories and criteria

### A) UX / Self-service
- Discoverability (search, ownership, tags)
- Rerun/backfill ergonomics
- Debug UX (logs, retries, diffs, parameter history)
- Notifications (noise control, actionable routing)

### B) Operational excellence
- SLO/SLI support + error budget enforcement hooks
- Multi-tenant isolation, quotas, priorities
- Auditability + run provenance

### C) Standards & governance
- Lineage/metadata support (OpenLineage or equivalent)
- RBAC model, secrets integration, compliance controls

### D) Execution plane fit (K8s reality)
- Native K8s execution, retries, backoff, sidecars
- Admission/queueing integration (e.g., batch queueing)
- Placement controls (constraints, topology, GPUs)

### E) Extensibility & ecosystem
- API-first, plug-in model, event hooks
- CI/CD and environment promotion
- Integration breadth (catalog, observability stack)

### F) Economics
- Cost transparency
- Autoscaling/bin-packing friendliness
- Operational overhead (toil to operate)
- Weighting suggestion (use this to avoid political fights)
- Data Scientists: A 35%, B 20%, C 15%, D 15%, E 10%, F 5%
- Data Analysts: A 30%, B 25%, C 25%, D 10%, E 5%, F 5%
- Data Engineers: A 15%, B 30%, C 20%, D 20%, E 10%, F 5%
- SRE/Infra: A 5%, B 30%, C 15%, D 30%, E 5%, F 15%

# 3) Stakeholder map + comms cadence (so adoption doesn’t implode)
## Stakeholder map (who you must win)
- Exec sponsor(s): want risk reduction + cost + time-to-value
- Legacy owners: fear losing control; often hold tribal knowledge
- Data Science / Analytics / Engineering leaders: want speed + trust + self-service
- SRE/Platform/Infra: want predictability, quotas, sane placement, fewer pages
- Security/Compliance: want auditability, access controls, approvals
- Finance/Capacity: want cost visibility and governance

## Cadence (simple, relentless, visible)
- Weekly (30 min): Orchestration LT sync — blockers, decisions, metrics
- Weekly: Office hours — “bring your pipeline,” your team fixes friction live
- Biweekly: User council (DS/DA/DE/SRE reps) — feedback, roadmap tradeoffs
- Monthly: Exec steering — adoption, reliability, cost, deprecations, top risks
- Every sprint: release notes + “what got easier” story + known issues

Tie comms to ADKAR: awareness (why), desire (what’s in it for me), knowledge/ability (training + templates), reinforcement (deprecation + incentives).

# 4) Migration wave model (how you unify without a big-bang disaster)
Use a Strangler Fig approach: create a façade/unified console first, route runs to legacy or new execution, then migrate capability incrementally.

## Wave 0 — Foundation (Weeks 1–6, overlaps with 30/60)
- Unified catalog + ownership model
- Unified run view (status/logs/links)
- Baseline lineage emission + RBAC standards
- SLOs + error budget policy (so reliability is enforced, not begged for)

## Wave 1 — Low-risk, high-volume “boring jobs”
- Simple batch jobs with clear inputs/outputs
- Biggest win: operational consistency + self-service
- Exit criteria: success rate under SLO, backfill works, alerting clean

## Wave 2 — Medium complexity dependency chains
- Multi-step ETL, cross-team dependencies
- Add stronger lineage + impact analysis expectations

## Wave 3 — High criticality / regulated / “if it fails we’re on the phone”
- Financial close, customer-facing SLAs, anything with compliance hooks
- Require full audit trail + change controls + rollback story

## Deprecation policy (don’t be timid)
- Publish dates early.
- “Legacy remains only as an execution backend until the last workflow migrates; the UX front door is unified ASAP.”
- Enforce “no net-new legacy” once the façade exists.